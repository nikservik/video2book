# AGENTS.md — Правила разработки Video2Book (Laravel + Livewire)

Документ описывает текущее состояние архитектуры Video2Book и правила внесения правок.

- Цель: развивать серверное приложение на Laravel с веб-интерфейсом на Livewire.
- Любое изменение кода сопровождаем обновлением документации и истории изменений (см. раздел «Документация и история изменений»).

## Источники истины

- `README.md` — обзор продукта, запуск окружений, требования.
- `AGENTS.md` — правила разработки, архитектурные договоренности и процесс.
- `docs/` — актуальные проектные документы и договоренности.
- `docs/old/` — архив исторических документов из desktop/monorepo периода.
- `CHANGELOG.md` — история изменений.

Если код и документация расходятся, приоритет у фактического кода. После исправления кода обязательно обновляем документы и фиксируем это в changelog.

## Архитектура

### Приложение (Laravel)

Проект находится в корне репозитория.

- `app/Http/Controllers` — API-контроллеры для проектов, уроков, пайплайнов, шагов и запусков пайплайнов.
- `app/Jobs` — фоновые задания (`ProcessPipelineJob`, `DownloadLessonAudioJob`).
- `app/Services/Pipeline` — оркестрация шагов, расчет статусов, экспорт результатов.
- `app/Services/Llm` — интеграционный слой с Laravel AI SDK, менеджер, usage/cost и rate-limits.
- `app/Services/Lesson` — загрузка и подготовка медиа по ссылкам.
- `app/Models` — доменные сущности и связи.
- `database/migrations` — схема данных.
- `routes/api.php` — публичный API.
- `routes/web.php` + `resources/views` — серверный веб-слой (Blade/Livewire).

### Веб-слой (Livewire)

- UI строим как серверный интерфейс на Livewire 4, без клиентского desktop-слоя.
- Компоненты размещаем в `app/Livewire` (или feature-подкаталогах внутри него), шаблоны — в `resources/views`.
- Новые страницы подключаем через `routes/web.php`.
- Общую бизнес-логику не дублируем в компонентах: переиспользуем `app/Services/*`.

### Очередь и выполнение пайплайнов

- Очередь `pipelines` выполняет `ProcessPipelineJob`.
- Один `PipelineRun` обрабатывается последовательно, шаг за шагом.
- Уникальные job и блокировки исключают параллельную обработку одного и того же прогона.
- При ошибке run/step получают `failed`, ретрай инициируется явно через API перезапуска.

## Доменные сущности и данные

### Проекты и уроки

- Проект (`projects`): `id`, `name`, `tags`.
- Урок (`lessons`): `project_id`, `name`, `tag`, `settings`, `source_filename`.
- Создание урока (`POST /api/lessons`) требует `pipeline_version_id` и создаёт первый `PipelineRun`.
- Аудио хранится в `storage/app/lessons/{id}.mp3`.

### Пайплайны

- `pipelines` содержит историю версий (`pipeline_versions`).
- Шаг (`steps`) — контейнер, данные шага лежат в `step_versions`.
- Поддерживаем типы шагов: `transcribe`, `text`, `glossary`.
- Изменения пайплайнов и шагов поддерживают режимы `current` и `new_version`.

### PipelineRun и PipelineRunStep

- `PipelineRun`: `queued|running|failed|done`, привязан к `lesson` и `pipeline_version`.
- `PipelineRunStep`: `pending|running|failed|done`, позиция, result/error, usage/cost.
- Перезапуск с шага: `POST /api/pipeline-runs/{run}/restart` с `step_id`.

### Формат API-ответов

- Базовый контракт: `{ success: boolean, data?, message?, error? }`.
- Ошибки должны быть осмысленными и возвращаться корректным HTTP-кодом.

## Практики разработки

### Laravel и Livewire

- Контроллеры: валидация и маршрутизация, минимум бизнес-логики.
- Бизнес-правила — в сервисах (`app/Services/*`).
- Валидация через `FormRequest` или `$request->validate`.
- Для тяжелых операций (LLM, скачивание, обработка) используем очереди, не блокируем HTTP-ответ.
- Livewire-компоненты должны вызывать сервисный слой, а не дублировать алгоритмы.

### Работа с LLM

- Используем `LlmManager` поверх Laravel AI SDK (`config/ai.php`), без прямых SDK-клиентов отдельных провайдеров в коде приложения.
- В каждом шаге обязательно сохраняем usage и стоимость.
- Конфигурация и цены живут в `config/llm.php` и `config/pricing.php`.

### Тесты

- Любые правки backend/Livewire сопровождаем тестами.
- Минимальный набор перед PR:
  - `php artisan test`
  - `./vendor/bin/pint --test`
- Для изменений веб-слоя добавляем feature-тесты HTTP/Livewire-сценариев.

## Код-стайл и качество

- Следуем стандартам Laravel 12 и PSR-12.
- Не добавляем шумные комментарии и избыточное логирование.
- Логи должны помогать диагностике внешних интеграций и ошибок очереди.

## Документация и история изменений

- Каждый завершённый шаг:
  - обновляем `README.md`, если меняется установка, UX, архитектура или инфраструктура;
  - обновляем релевантные документы в `docs/`;
  - добавляем запись в `CHANGELOG.md` в формате:
    - `## [YYYY-MM-DD] feat|fix|docs|refactor: описание`.
- Исторические материалы сохраняем в `docs/old/` и не используем их как текущие требования.

## Рабочий процесс

1. Перед началом читаем `README.md`, `AGENTS.md` и релевантные документы из `docs/`.
2. Составляем короткий план (5-7 пунктов) и синхронизируем ожидания.
3. Вносим изменения небольшими логическими порциями.
4. Прогоняем тесты и обновляем документацию/чейнджлог в том же шаге.

## Дополнительные рекомендации

- При добавлении новых шагов пайплайна проверяем совместимость с `PipelineRunProcessingService`.
- При изменении формата результата шага синхронизируем экспортеры (`PipelineStepPdfExporter`) и API.
- Новые документы создаём в `docs/`, а архивные материалы складываем в `docs/old/`.
