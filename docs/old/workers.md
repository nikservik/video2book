# Обработка проекта по пайплайну

Нам нужно организовать обработку проектов по пайплайнам. Структура данных для этого уже подготовлена, нужно организовать работу очереди задач.

Для каждого Project может быть несльконо PipelineRun. У PipelineRun есть список PipelineRunStep, которые хранят статус и результат выполнения каждого шага.
PipelineRun - это прогон пайплайна, состояние обработки хранится в поле status (queued|running|failed|done).
Состояние обработки шага хранится в поле status каждого шага (pending|running|failed|done).

## Постановка в очередь
Запрос api с параметрами:
- project_id
- pipeline_version_id

Создает экземпляр PipelineRun и диспатчит для него задачу ProcessPipelineJob(PipelineRun) в очередь pipelines.

### Создание PipelineRun
- Создаем экземпляр PipelineRun с заданной pipeline_version_id и status=queued
- На основе последовательности шагов связанной PipelineVersion создаем набор PipelineRunStep со status=pending и соответствующими position

## Обработка в очереди
- отдельная очередь - pipelines
- единственный Job - ProcessPipelineJob(PipelineRun)
- делает lock по pipeline_run_id, чтобы обеспечить линейную обработку шагов в пайплайне. один воркер на прогон
- атомарно “забирает” следующий pending‑шаг (по position)
- берет на вход результат шага-источника или медиа-файл и выполняет запрос из соответствующего шага связанной версии пайплайна
- фиксирует результат и метрики в PipelineRunStep
- если остались шаги - диспатчит следующий job и сразу выходит

Реализация “один воркер на прогон” в Laravel
- Illuminate\Queue\Middleware\WithoutOverlapping позволяет предотвращать одновременное выполнение job’ов по ключу.  ￼
- Важно: expireAfter(...) — обязателен при долгих задачах, чтобы “зависший” lock не жил вечно.  ￼

### Как “выбирать следующий шаг” без гонок

Критично сделать так, чтобы при ретраях/дубликатах job не взял тот же шаг второй раз.

“взять следующий шаг” делается в транзакции: SELECT ... WHERE status='pending' ORDER BY position LIMIT 1 FOR UPDATE, затем UPDATE status='running', start_time=....

### Защита от дубликатов на уровне очереди

Дополнительно можно использовать Unique Jobs:
- реализовать ShouldBeUnique и сделать uniqueId() = "run:$runId:step:$stepId".  ￼
Это уменьшает шанс, что в очереди окажутся два одинаковых job’а на один и тот же шаг.

### Таймауты/ретраи (важно при 5–15 мин)

Laravel явно предупреждает:
	•	есть --timeout у воркера и $timeout у job;
	•	$timeout job должен быть меньше, чем retry_after, иначе job может быть повторно взят, пока первый ещё работает.  ￼
И ещё: IO‑операции (HTTP/сокеты) могут не уважать общий таймаут, поэтому таймауты нужно задавать и на HTTP‑клиенте тоже.  ￼

## Состояние очереди
В API нужно отдавать состояние очереди обработки пайплайнов.

Возвращаем список PipelineRun со статусом running|queued.
Для каждого PipelineRun добавляем сокращенный массив шагов: без поля result.

## Перезапуск PipelineRun с заданного шага

Нужно добавить endpoint для перезапуска прогона.
На вход подается PipelineRunID и PipelineRunStepID.
Нужно сбросить состояние всех шагов в этом PipelineRun, начиная с указанного. Поставить статус равным pending.
и диспатчить задачу обработки этого PipelineRun.

## Рефакторинг проектов

### 1) Нужно переименовать project в lesson на бекенде.
- таблицы и модели
- эндпоинты api
- индексы в json-ответах api

В миграциях можно не бепокоиться о сохранности данных, их еще нет.
В api не нужно сохранять обратную совместимость, фронт еще не работает с api проектов.
Модель ProjectTag остается без изменений, при этом у Lesson остается поле tag.

### 2) Нужно добавить модель project, которая содержит набор lesson.
project
- id
- name (string)
- tags (string)
